tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q1,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q1,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u1 = 2,
alpha1 = 0.5,
u2 = 2,
alpha2 = 0.5
)
tmbparams <- list(
W = rep(0, n), # W = c(U); U = B-Spline coefficients
theta1 = 0, # -2log(sigma)
theta2 = 0
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "02_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
begin_time <- Sys.time()
quad <- aghq::marginal_laplace_tmb(ff,7,c(0,0))
end_time <- Sys.time()
time1 <- end_time - begin_time
# Plot of theta posterior
logpostsigma1 <- compute_pdf_and_cdf(quad$marginals[[1]],list(totheta = function(x) -2*log(x),fromtheta = function(x) exp(-x/2)))
with(logpostsigma1,plot(transparam,pdf_transparam,type='l'))
logpostsigma2 <- compute_pdf_and_cdf(quad$marginals[[2]],list(totheta = function(x) -2*log(x),fromtheta = function(x) exp(-x/2)))
with(logpostsigma2,plot(transparam,pdf_transparam,type='l'))
# Inference for W
samps1 <- sample_marginal(quad,1e03)
# Posterior mean
W1 <- apply(samps1$samps,1,mean)
L1 <- apply(samps1$samps,1,quantile, probs = 0.025)
U1 <- apply(samps1$samps,1,quantile, probs = 0.975)
#### Approach 2: Using RW2 model without Diaognal Approximation
Q2 <- t(H) %*% solve(B) %*% H
Q2 <- as(as.matrix(Q2 + Diagonal(n, x = 0.0001)), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q2,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q2,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u1 = 2,
alpha1 = 0.5,
u2 = 2,
alpha2 = 0.5
)
tmbparams <- list(
W = rep(0, n), # W = c(U); U = B-Spline coefficients
theta1 = 0, # -2log(sigma)
theta2 = 0
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "02_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
begin_time <- Sys.time()
quad <- aghq::marginal_laplace_tmb(ff,7,c(0,0))
end_time <- Sys.time()
time2 <- end_time - begin_time
# Plot of theta posterior
logpostsigma1 <- compute_pdf_and_cdf(quad$marginals[[1]],list(totheta = function(x) -2*log(x),fromtheta = function(x) exp(-x/2)))
with(logpostsigma1,plot(transparam,pdf_transparam,type='l'))
logpostsigma2 <- compute_pdf_and_cdf(quad$marginals[[2]],list(totheta = function(x) -2*log(x),fromtheta = function(x) exp(-x/2)))
with(logpostsigma2,plot(transparam,pdf_transparam,type='l'))
# Inference for W
samps2 <- sample_marginal(quad,1e03)
# Posterior mean
W2 <- apply(samps2$samps,1,mean)
L2 <- apply(samps2$samps,1,quantile, probs = 0.025)
U2 <- apply(samps2$samps,1,quantile, probs = 0.975)
#### Approach 3: Using ARIMA method
D <- H[-c(1,n),]
R <- B[-c(1,n), -c(1,n)]
Q3 <- t(D) %*% solve(R) %*% D
Q3 <- as(as.matrix(Q3 + Diagonal(n, x = 0.0001)), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q3,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q3,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u1 = 2,
alpha1 = 0.5,
u2 = 2,
alpha2 = 0.5
)
tmbparams <- list(
W = rep(0, n), # W = c(U); U = B-Spline coefficients
theta1 = 0, # -2log(sigma)
theta2 = 0
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "02_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
begin_time <- Sys.time()
quad <- aghq::marginal_laplace_tmb(ff,7,c(0,0))
end_time <- Sys.time()
time3 <- end_time - begin_time# Plot of theta posterior
logpostsigma1 <- compute_pdf_and_cdf(quad$marginals[[1]],list(totheta = function(x) -2*log(x),fromtheta = function(x) exp(-x/2)))
with(logpostsigma1,plot(transparam,pdf_transparam,type='l'))
logpostsigma2 <- compute_pdf_and_cdf(quad$marginals[[2]],list(totheta = function(x) -2*log(x),fromtheta = function(x) exp(-x/2)))
with(logpostsigma2,plot(transparam,pdf_transparam,type='l'))
# Inference for W
samps3 <- sample_marginal(quad,1e03)
# Posterior mean
W3 <- apply(samps3$samps,1,mean)
L3 <- apply(samps3$samps,1,quantile, probs = 0.025)
U3 <- apply(samps3$samps,1,quantile, probs = 0.975)
mean((5*sin(0.5*x)-W1)^2)
mean((5*sin(0.5*x)-W2)^2)
mean((5*sin(0.5*x)-W3)^2)
mean((5*sin(0.5*x) <= U1) & (5*sin(0.5*x) >= L1))
mean((5*sin(0.5*x) <= U2) & (5*sin(0.5*x) >= L2))
mean((5*sin(0.5*x) <= U3) & (5*sin(0.5*x) >= L3))
time1
time2
time3
mean((5*sin(0.5*x)-W1)^2)
mean((5*sin(0.5*x)-W2)^2)
mean((5*sin(0.5*x)-W3)^2)
mean((5*sin(0.5*x) <= U1) & (5*sin(0.5*x) >= L1))
mean((5*sin(0.5*x) <= U2) & (5*sin(0.5*x) >= L2))
mean((5*sin(0.5*x) <= U3) & (5*sin(0.5*x) >= L3))
n <- 500
x <- seq(0.1,50, by = 0.1)
ylat <- log(5*sin(0.5*x) + 6)
y <- rpois(n,lambda = exp(ylat))
d <- diff(x)
X <- as(as.matrix(Diagonal(n)), "dgTMatrix")
H <- compute_H_rue(d,n = length(x))
B <- compute_B(d,n = length(x))
A <- compute_A(d, n = length(x))
Q1 <- t(H) %*% solve(A) %*% H
Q1 <- as(Q1 + Diagonal(n, x = 0.0001), "dgTMatrix")
# compile("03_RW2Comparison.cpp")
dyn.load(dynlib("03_RW2Comparison"))
### Approach 1:
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q1,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q1,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u = 2,
alpha = 0.5
)
tmbparams <- list(
W = rep(0, n), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "03_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
begin_time <- Sys.time()
quad <- aghq::marginal_laplace_tmb(ff,7,c(0))
end_time <- Sys.time()
time1 <- end_time - begin_time
# Inference for W
samps1 <- sample_marginal(quad,1e03)
# Posterior mean
W1 <- apply(samps1$samps,1,mean)
L1 <- apply(samps1$samps,1,quantile, probs = 0.025)
U1 <- apply(samps1$samps,1,quantile, probs = 0.975)
### Approach 2:
Q2 <- t(H) %*% solve(B) %*% H
Q2 <- as(as.matrix(Q2 + Diagonal(n, x = 0.0001)), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q2,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q2,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u = 2,
alpha = 0.5
)
tmbparams <- list(
W = rep(0, n), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "03_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
begin_time <- Sys.time()
quad <- aghq::marginal_laplace_tmb(ff,7,c(0))
end_time <- Sys.time()
time2 <- end_time - begin_time
# Inference for W
samps2 <- sample_marginal(quad,1e03)
# Posterior mean
W2 <- apply(samps2$samps,1,mean)
L2 <- apply(samps2$samps,1,quantile, probs = 0.025)
U2 <- apply(samps2$samps,1,quantile, probs = 0.975)
#### Approach 3:
D <- H[-c(1,n),]
R <- B[-c(1,n), -c(1,n)]
Q3 <- t(D) %*% solve(R) %*% D
Q3 <- as(as.matrix(Q3 + Diagonal(n, x = 0.0001)), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q3,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q3,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u = 2,
alpha = 0.5
)
tmbparams <- list(
W = rep(0, n), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "03_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
begin_time <- Sys.time()
quad <- aghq::marginal_laplace_tmb(ff,7,c(0))
end_time <- Sys.time()
time3 <- end_time - begin_time
# Inference for W
samps3 <- sample_marginal(quad,1e03)
# Posterior mean
W3 <- apply(samps3$samps,1,mean)
L3 <- apply(samps3$samps,1,quantile, probs = 0.025)
U3 <- apply(samps3$samps,1,quantile, probs = 0.975)
time1
time2
time3
#### Comparison
plot(y~x)
lines(W1~x, col = "Red")
lines(U1~x, col = "Red", lty=2)
lines(L1~x, col = "Red", lty=2)
lines(W2~x, col = "blue")
lines(U2~x, col = "blue", lty=2)
lines(L2~x, col = "blue", lty=2)
lines(W3~x, col = "green")
lines(U3~x, col = "green", lty=2)
lines(L3~x, col = "green", lty=2)
lines(5*sin(0.5*x)~x, col = "black")
#### Comparison
plot(log(5*sin(0.5*x) + 6)~x)
lines(W1~x, col = "Red")
lines(U1~x, col = "Red", lty=2)
lines(L1~x, col = "Red", lty=2)
lines(W2~x, col = "blue")
lines(U2~x, col = "blue", lty=2)
lines(L2~x, col = "blue", lty=2)
lines(W3~x, col = "green")
lines(U3~x, col = "green", lty=2)
lines(L3~x, col = "green", lty=2)
lines(5*sin(0.5*x)~x, col = "black")
#### Comparison
plot(log(5*sin(0.5*x) + 6)~x, type = 'l)
lines(W1~x, col = "Red")
lines(U1~x, col = "Red", lty=2)
lines(L1~x, col = "Red", lty=2)
lines(W2~x, col = "blue")
lines(U2~x, col = "blue", lty=2)
lines(L2~x, col = "blue", lty=2)
lines(W3~x, col = "green")
lines(U3~x, col = "green", lty=2)
lines(L3~x, col = "green", lty=2)
lines(5*sin(0.5*x)~x, col = "black")
#### Comparison
plot(log(5*sin(0.5*x) + 6)~x, type = 'l')
lines(W1~x, col = "Red")
lines(U1~x, col = "Red", lty=2)
lines(L1~x, col = "Red", lty=2)
lines(W2~x, col = "blue")
lines(U2~x, col = "blue", lty=2)
lines(L2~x, col = "blue", lty=2)
lines(W3~x, col = "green")
lines(U3~x, col = "green", lty=2)
lines(L3~x, col = "green", lty=2)
lines(5*sin(0.5*x)~x, col = "black")
#### Comparison
plot(log(5*sin(0.5*x) + 6)~x, type = 'l')
lines(W1~x, col = "Red")
lines(U1~x, col = "Red", lty=2)
lines(L1~x, col = "Red", lty=2)
lines(W2~x, col = "blue")
lines(U2~x, col = "blue", lty=2)
lines(L2~x, col = "blue", lty=2)
lines(W3~x, col = "green")
lines(U3~x, col = "green", lty=2)
lines(L3~x, col = "green", lty=2)
mean((log(5*sin(0.5*x)+6)-W1)^2)
mean((log(5*sin(0.5*x)+6)-W2)^2)
mean((log(5*sin(0.5*x)+6)-W3)^2)
mean((log(5*sin(0.5*x)+6) <= U1) & (log(5*sin(0.5*x)+6) >= L1))
mean((log(5*sin(0.5*x)+6) <= U2) & (log(5*sin(0.5*x)+6) >= L2))
mean((log(5*sin(0.5*x)+6) <= U3) & (log(5*sin(0.5*x)+6) >= L3))
set.seed(123,sample.kind="Rounding")
n <- 500
x <- seq(0.1,50, by = 0.1)
ylat <- log(5*sin(0.5*x) + 6)
y <- rpois(n,lambda = exp(ylat))
d <- diff(x)
X <- as(as.matrix(Diagonal(n)), "dgTMatrix")
H <- compute_H_rue(d,n = length(x))
B <- compute_B(d,n = length(x))
A <- compute_A(d, n = length(x))
Q1 <- t(H) %*% solve(A) %*% H
Q1 <- as(Q1 + Diagonal(n, x = 0.0001), "dgTMatrix")
# compile("03_RW2Comparison.cpp")
dyn.load(dynlib("03_RW2Comparison"))
### Approach 1:
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q1,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q1,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u = 2,
alpha = 0.5
)
tmbparams <- list(
W = rep(0, n), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "03_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
begin_time <- Sys.time()
quad <- aghq::marginal_laplace_tmb(ff,7,c(0))
end_time <- Sys.time()
time1 <- end_time - begin_time
# Inference for W
samps1 <- sample_marginal(quad,1e03)
# Posterior mean
W1 <- apply(samps1$samps,1,mean)
L1 <- apply(samps1$samps,1,quantile, probs = 0.025)
U1 <- apply(samps1$samps,1,quantile, probs = 0.975)
### Approach 2:
Q2 <- t(H) %*% solve(B) %*% H
Q2 <- as(as.matrix(Q2 + Diagonal(n, x = 0.0001)), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q2,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q2,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u = 2,
alpha = 0.5
)
tmbparams <- list(
W = rep(0, n), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "03_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
begin_time <- Sys.time()
quad <- aghq::marginal_laplace_tmb(ff,7,c(0))
end_time <- Sys.time()
time2 <- end_time - begin_time
# Inference for W
samps2 <- sample_marginal(quad,1e03)
# Posterior mean
W2 <- apply(samps2$samps,1,mean)
L2 <- apply(samps2$samps,1,quantile, probs = 0.025)
U2 <- apply(samps2$samps,1,quantile, probs = 0.975)
#### Approach 3:
D <- H[-c(1,n),]
R <- B[-c(1,n), -c(1,n)]
Q3 <- t(D) %*% solve(R) %*% D
Q3 <- as(as.matrix(Q3 + Diagonal(n, x = 0.0001)), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q3,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q3,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u = 2,
alpha = 0.5
)
tmbparams <- list(
W = rep(0, n), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "03_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
begin_time <- Sys.time()
quad <- aghq::marginal_laplace_tmb(ff,7,c(0))
end_time <- Sys.time()
time3 <- end_time - begin_time
# Inference for W
samps3 <- sample_marginal(quad,1e03)
# Posterior mean
W3 <- apply(samps3$samps,1,mean)
L3 <- apply(samps3$samps,1,quantile, probs = 0.025)
U3 <- apply(samps3$samps,1,quantile, probs = 0.975)
#### Comparison
plot(log(5*sin(0.5*x) + 6)~x, type = 'l')
lines(W1~x, col = "Red")
lines(U1~x, col = "Red", lty=2)
lines(L1~x, col = "Red", lty=2)
lines(W2~x, col = "blue")
lines(U2~x, col = "blue", lty=2)
lines(L2~x, col = "blue", lty=2)
lines(W3~x, col = "green")
lines(U3~x, col = "green", lty=2)
lines(L3~x, col = "green", lty=2)
mean((log(5*sin(0.5*x)+6)-W1)^2)
mean((log(5*sin(0.5*x)+6)-W2)^2)
mean((log(5*sin(0.5*x)+6)-W3)^2)
mean((log(5*sin(0.5*x)+6) <= U1) & (log(5*sin(0.5*x)+6) >= L1))
mean((log(5*sin(0.5*x)+6) <= U2) & (log(5*sin(0.5*x)+6) >= L2))
mean((log(5*sin(0.5*x)+6) <= U3) & (log(5*sin(0.5*x)+6) >= L3))
time1
time2
time3
