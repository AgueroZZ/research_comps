D <- H[-c(1,length(x1)),]
R <- B[-c(1,length(x1)), -c(1,length(x1))]
Q3 <- t(D) %*% solve(R) %*% D
Q3
t(D) %*% solve(A) %*% D
t(H) %*% solve(A) %*% H
t(D) %*% solve(R) %*% D
library(INLA)
library(mgcv)
library(TMB)
library(aghq)
n <- 500
x <- seq(0.1,50, by = 0.1)
y <- 5*sin(0.5*x) + rnorm(n, sd = 1)
d <- diff(x)
X <- as(as.matrix(Diagonal(n)), "dgTMatrix")
#### Approach 1: Using RW2 model with Diaognal Approximation
compute_H_rue <- function(d,n){
H <- matrix(data = 0, nrow = n, ncol = n)
for (i in 2:(nrow(H)-1)) {
H[i,i] <- -(1/d[i-1]+1/d[i])
H[i,i-1] <- 1/d[i-1]
H[i,i+1] <- 1/d[i]
}
H
}
compute_B <- function(d,n){
B <-matrix(0, nrow = n, ncol = n)
B[1,1] <- d[1]/3
B[1,2] <- d[1]/6
B[n,n-1] <- d[n-1]/6
B[n,n] <- d[n-1]/3
for (i in 2:(nrow(B)-1)) {
B[i,i-1] <- d[i-1]/6
B[i,i] <- (d[i-1]+d[i])/3
B[i,i+1] <- d[i]/6
}
B
}
compute_A <- function(d,n){
A <-matrix(0, nrow = n, ncol = n)
A[1,1] <- d[1]/2
A[n,n] <- d[n-1]/2
for (i in 2:(nrow(A)-1)) {
A[i,i] <- (d[i-1]+d[i])/2
}
A
}
H <- compute_H_rue(d,n = length(x))
B <- compute_B(d,n = length(x))
A <- compute_A(d, n = length(x))
Q1 <- t(H) %*% solve(A) %*% H
Q1 <- as(Q1 + Diagonal(n, x = 0.0001), "dgTMatrix")
compile("01_RW2Comparison.cpp")
dyn.load(dynlib("01_RW2Comparison"))
compile("01_RW2Comparison.cpp")
dyn.load(dynlib("01_RW2Comparison"))
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q1,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q1,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u = 2,
alpha = 0.5
)
tmbparams <- list(
W = rep(0, n), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "01_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
quad <- aghq::marginal_laplace_tmb(ff,7,0)
# Plot of theta posterior
logpostsigma <- compute_pdf_and_cdf(quad$marginals[[1]],list(totheta = function(x) -2*log(x),fromtheta = function(x) exp(-x/2)))
with(logpostsigma,plot(transparam,pdf_transparam,type='l'))
# Inference for W
samps1 <- sample_marginal(quad,1e03)
samps1
x
bs(x, degree = 1)
library(mgcv)
bs
library(splines)
bs
bs(x, degree = 1)
splineFunc <- bs(x, degree = 1)
splineFuc
splineFunc
length(x)
knots = c(1,2,3,4)
splineFunc <- bs(x, knots = knots, degree = 1)
splineFunc
X <- seq(0,1, by = 0.01)
X
knots <- seq(0,1, by = 0.1)
knots
splineBasis <- splines::bs(x, knots = knots, degree = 1)
splineBasis
splineBasis[1,]
splineBasis[2]
splineBasis[2,]
dim(splineBasis)
splineBasis[1,]
splineBasis[500,]
splineBasis[1,]
splineBasis[2,]
length(knots)
length(X)
splineBasis <- splines::bs(X, knots = knots, degree = 1)
splineBasis
dim(splineBasis)
length(X)
plot(splineBasis[1,]~X, type = "l")
length(X)
plot(splineBasis[,1]~X, type = "l")
length(knots)
knots
splineBasis[,1]
splineBasis[1,]
splineBasis[2,]
plot(splineBasis[,1]~X, type = "l", col = "blue")
for (i in 2:12) {
lines(splineBasis[,i]~X, col = "blue")
}
samps1$samps
samps1$samps[,1]
length(samps1$samps[,1])
weights <- rnorm(n = length(knots))
weights
splineBasis %*% matrix(weights, ncol = 1)
matrix(weights, ncol = 1)
splineBasis
plot(splineBasis[,1]~X, type = "l", col = "blue")
for (i in 2:11) {
lines(splineBasis[,i]~X, col = "blue")
}
lines(splineBasis[,12]~X, col = "red")
splineBasis <- splines::bs(X, knots = knots, degree = 1, intercept = F)
splineBasis
### Ploting:
plot(splineBasis[,1]~X, type = "l", col = "blue")
for (i in 2:11) {
lines(splineBasis[,i]~X, col = "blue")
}
lines(splineBasis[,11]~X, col = "red")
### now suppose we already know the weights vector:
weights <- rnorm(n = length(knots))
fitted_func <- splineBasis %*% matrix(weights, ncol = 1)
matrix(weights, ncol = 1)
splineBasis
splineBasis[,-12]
fitted_func <- splineBasis[,-12] %*% matrix(weights, ncol = 1)
fitted_func
lines(splineBasis[,11]~X, col = "red")
plot(fitted_func~X, type = "l", col = "purple")
x <- seq(0.1,50, by = 0.1)
a <- min(x)
b <- max(x)
library(INLA)
library(mgcv)
library(TMB)
library(aghq)
#################Generating Gaussian Data for Smoothing ##############
######################################################################
#### Assuming true sigma is known to be 1
n <- 500
x <- seq(0.1,50, by = 0.1)
a <- min(x)
b <- max(x)
y <- 5*sin(0.5*x) + rnorm(n, sd = 1)
d <- diff(x)
X <- as(as.matrix(Diagonal(n)), "dgTMatrix")
#### Approach 1: Using RW2 model with Diaognal Approximation
compute_H_rue <- function(d,n){
H <- matrix(data = 0, nrow = n, ncol = n)
for (i in 2:(nrow(H)-1)) {
H[i,i] <- -(1/d[i-1]+1/d[i])
H[i,i-1] <- 1/d[i-1]
H[i,i+1] <- 1/d[i]
}
H
}
compute_B <- function(d,n){
B <-matrix(0, nrow = n, ncol = n)
B[1,1] <- d[1]/3
B[1,2] <- d[1]/6
B[n,n-1] <- d[n-1]/6
B[n,n] <- d[n-1]/3
for (i in 2:(nrow(B)-1)) {
B[i,i-1] <- d[i-1]/6
B[i,i] <- (d[i-1]+d[i])/3
B[i,i+1] <- d[i]/6
}
B
}
compute_A <- function(d,n){
A <-matrix(0, nrow = n, ncol = n)
A[1,1] <- d[1]/2
A[n,n] <- d[n-1]/2
for (i in 2:(nrow(A)-1)) {
A[i,i] <- (d[i-1]+d[i])/2
}
A
}
H <- compute_H_rue(d,n = length(x))
B <- compute_B(d,n = length(x))
A <- compute_A(d, n = length(x))
Q1 <- t(H) %*% solve(A) %*% H
Q1 <- as(Q1 + Diagonal(n, x = 0.0001), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q1,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q1,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u = 2,
alpha = 0.5
)
tmbparams <- list(
W = rep(0, n), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "01_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
quad <- aghq::marginal_laplace_tmb(ff,7,0)
# Plot of theta posterior
logpostsigma <- compute_pdf_and_cdf(quad$marginals[[1]],list(totheta = function(x) -2*log(x),fromtheta = function(x) exp(-x/2)))
with(logpostsigma,plot(transparam,pdf_transparam,type='l'))
samps1 <- sample_marginal(quad,1e03)
samps1[,1]
samps1[1,]
samps1$samps[,1]
length(samps1$samps[,1])
# Use evaluation vector to reconstruct the fitted function:
construct_fitted <- function(weights, resolution = 0.001){
knots <- x
location_interest <- seq(a,b, by = resolution)
splineFunc <- splines::bs(location_interest, degree = 1, knots = knots)
fitted_func <- splineBasis[,-(length(knots) + 1)] %*% matrix(weights, ncol = 1)
fitted_func
}
construct_fitted(weights = samps1$samps[,1], resolution = 0.001)
construct_fitted <- function(weights, resolution = 0.001){
knots <- x
location_interest <- seq(a,b, by = resolution)
splineFunc <- splines::bs(location_interest, degree = 1, knots = knots)
fitted_func <- splineFunc[,-(length(knots) + 1)] %*% matrix(weights, ncol = 1)
fitted_func
}
construct_fitted(weights = samps1$samps[,1], resolution = 0.001)
# Use evaluation vector to reconstruct the fitted function:
construct_fitted <- function(weights, resolution = 0.001){
knots <- x
location_interest <- seq(a,b, by = resolution)
splineFunc <- splines::bs(location_interest, degree = 1, knots = knots)
fitted_func <- splineFunc[,-(length(knots) + 1)] %*% matrix(weights, ncol = 1)
numeric(fitted_func)
}
construct_fitted(weights = samps1$samps[,1], resolution = 0.001)
# Use evaluation vector to reconstruct the fitted function:
construct_fitted <- function(weights, resolution = 0.001){
knots <- x
location_interest <- seq(a,b, by = resolution)
splineFunc <- splines::bs(location_interest, degree = 1, knots = knots)
fitted_func <- splineFunc[,-(length(knots) + 1)] %*% matrix(weights, ncol = 1)
as.numeric(fitted_func)
}
construct_fitted(weights = samps1$samps[,1], resolution = 0.001)
# Use evaluation vector to reconstruct the fitted function:
construct_fitted <- function(weights){
knots <- x
splineFunc <- splines::bs(location_interest, degree = 1, knots = knots)
fitted_func <- splineFunc[,-(length(knots) + 1)] %*% matrix(weights, ncol = 1)
as.numeric(fitted_func)
}
# Inference for W
samps1 <- sample_marginal(quad,1e03)
resolution = 0.001
location_interest <- seq(a,b, by = resolution)
construct_fitted(weights = samps1$samps[,1], resolution = 0.001)
construct_fitted(weights = samps1$samps[,1])
fitted_func <- construct_fitted(weights = samps1$samps[,1])
plot(fitted_func~x, col = "blue")
plot(fitted_func~location_interest, col = "blue", type = "l")
sample.int(10,1)
sample.int(10,1)
sample.int(10,1)
sample.int(10,1)
sample.int(10,1)
sample.int(10,1)
sample.int(10,1)
sample.int(10,1)
sample.int(10,1)
sample.int(1000,10)
sample.int(1000,10, replace = F)
?apply
sample_weights <- apply(samps1$samps, margin = 2, fitted_func)
sample_weights <- apply(samps1$samps, margin = 2, FUN = fitted_func)
sample_weights <- apply(samps1$samps, margin = 2, FUN = construct_fitted)
sample_weights <- apply(samps1$samps, MARGIN = 2, FUN = construct_fitted)
sample_weights
sample_func <- sample_weights
dim(sample_func)
length(location_interest)
length(x)
mean_func <- apply(sample_func,1,mean)
plot(mean_func~location_interest, col = "blue", type = "l")
plot(mean_func~location_interest, col = "blue", type = "l")
for (i in sample.int(1000,300)) {
lines(sample_func[,i] ~ location_interest, col = "grey")
}
plot(mean_func~location_interest, col = "blue", type = "l")
for (i in sample.int(1000,50)) {
lines(sample_func[,i] ~ location_interest, col = "grey")
}
#### Approach 2: Using RW2 model without Diagonal Approximation
Q2 <- t(H) %*% solve(B) %*% H
Q2 <- as(as.matrix(Q2 + Diagonal(n, x = 0.0001)), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q2,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q2,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u = 2,
alpha = 0.5
)
tmbparams <- list(
W = rep(0, n), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "01_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
quad <- aghq::marginal_laplace_tmb(ff,7,0)
# Plot of theta posterior
logpostsigma <- compute_pdf_and_cdf(quad$marginals[[1]],list(totheta = function(x) -2*log(x),fromtheta = function(x) exp(-x/2)))
with(logpostsigma,plot(transparam,pdf_transparam,type='l'))
# Inference for W
samps2 <- sample_marginal(quad,1e03)
resolution = 0.001
location_interest <- seq(a,b, by = resolution)
fitted_func <- construct_fitted(weights = samps2$samps[,1])
plot(fitted_func~location_interest, col = "blue", type = "l")
# Construct samples for g(.):
sample_func <- apply(samps2$samps, MARGIN = 2, FUN = construct_fitted)
?spline
x
spline(x, y = rnorm(length(x)), n = 10*length(x), method = "natural",
xmin = min(x), xmax = max(x), xout, ties = mean)
spline(x, y = rnorm(length(x)), n = 10*length(x), method = "natural",
xmin = min(x), xmax = max(x), ties = mean)
spline <- spline(x, y = rnorm(length(x)), n = 10*length(x), method = "natural",
xmin = min(x), xmax = max(x), ties = mean)
spline_fitted <- spline(x, y = rnorm(length(x)), n = 10*length(x), method = "natural",
xmin = min(x), xmax = max(x), ties = mean)
spline_fitted
plot(spline_fitted~x, type = 'l', col = 'blue')
plot(spline_fitted$y~x, type = 'l', col = 'blue')
plot(spline_fitted$y~spline_fitted$x, type = 'l', col = 'blue')
x
x <- seq(0,1,by = 0.1)
x
spline(x, y = NULL, n = 100*length(x), method = "natural",
xmin = min(x), xmax = max(x), ties = mean)
construct_fitted_cubic <- function(weights){
spline_fitted <- spline(x, y = weights, xout = x, method = "natural",
xmin = min(x), xmax = max(x), ties = mean)
spline_fitted
}
construct_fitted_cubic(seq(0,1,by = 0.1))
construct_fitted_cubic(location_interest)
construct_fitted_cubic <- function(weights){
x <- location_interest
spline_fitted <- spline(x, y = weights, xout = x, method = "natural",
xmin = min(x), xmax = max(x), ties = mean)
spline_fitted$x
}
#### Approach 3: Using ARIMA method
D <- H[-c(1,n),]
R <- B[-c(1,n), -c(1,n)]
Q3 <- t(D) %*% solve(R) %*% D
Q3 <- as(as.matrix(Q3 + Diagonal(n, x = 0.0001)), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q3,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q3,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u = 2,
alpha = 0.5
)
tmbparams <- list(
W = rep(0, n), # W = c(U); U = B-Spline coefficients
theta = 0 # -2log(sigma)
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "01_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
quad <- aghq::marginal_laplace_tmb(ff,7,0)
# Plot of theta posterior
logpostsigma <- compute_pdf_and_cdf(quad$marginals[[1]],list(totheta = function(x) -2*log(x),fromtheta = function(x) exp(-x/2)))
with(logpostsigma,plot(transparam,pdf_transparam,type='l'))
# Inference for W
samps3 <- sample_marginal(quad,1e03)
construct_fitted_cubic <- function(weights){
x <- location_interest
spline_fitted <- spline(x, y = weights, xout = x, method = "natural",
xmin = min(x), xmax = max(x), ties = mean)
spline_fitted$y
}
location_interest
sample_func <- apply(samps3$samps, MARGIN = 2, FUN = construct_fitted_cubic)
samps3$samps[,1]
length(samps3$samps[,1])
construct_fitted_cubic <- function(weights){
spline_fitted <- spline(x, y = weights, xout = location_interest, method = "natural",
xmin = min(x), xmax = max(x), ties = mean)
spline_fitted$y
}
sample_func <- apply(samps3$samps, MARGIN = 2, FUN = construct_fitted_cubic)
x
x <- seq(0.1,50, by = 0.1)
construct_fitted_cubic <- function(weights){
spline_fitted <- spline(x, y = weights, xout = location_interest, method = "natural",
xmin = min(x), xmax = max(x), ties = mean)
spline_fitted$y
}
sample_func <- apply(samps3$samps, MARGIN = 2, FUN = construct_fitted_cubic)
sample_func <- apply(samps3$samps, MARGIN = 2, FUN = construct_fitted_cubic)
sample_func
dim(sample_func)
### Plot:
plot(mean_func~location_interest, col = "blue", type = "l")
for (i in sample.int(1000,50)) {
lines(sample_func[,i] ~ location_interest, col = "grey")
}
plot(mean_func~location_interest, col = "blue", type = "l")
######## Linear way:
sample_func <- apply(samps3$samps, MARGIN = 2, FUN = construct_fitted)
mean_func <- apply(sample_func,1,mean)
### Plot:
plot(mean_func~location_interest, col = "blue", type = "l")
for (i in sample.int(1000,50)) {
lines(sample_func[,i] ~ location_interest, col = "grey")
}
plot(mean_func~location_interest, col = "blue", type = "l")
######## Cubic way:
sample_func_cubic <- apply(samps3$samps, MARGIN = 2, FUN = construct_fitted_cubic)
mean_func_cubic <- apply(sample_func_cubic,1,mean)
### Plot:
plot(mean_func_cubic~location_interest, col = "blue", type = "l")
for (i in sample.int(1000,50)) {
lines(sample_func_cubic[,i] ~ location_interest, col = "grey")
}
######## Linear way:
sample_func <- apply(samps3$samps, MARGIN = 2, FUN = construct_fitted)
mean_func <- apply(sample_func,1,mean)
### Plot:
plot(mean_func~location_interest, col = "blue", type = "l")
for (i in sample.int(1000,50)) {
lines(sample_func[,i] ~ location_interest, col = "grey")
}
plot(mean_func~location_interest, col = "blue", type = "l")
plot(mean_func_cubic~location_interest, col = "blue", type = "l")
