H <- compute_H_rue(d,n = length(x))
B <- compute_B(d,n = length(x))
A <- compute_A(d, n = length(x))
###### RW2:
Q1 <- t(H) %*% solve(A) %*% H
Q1 <- as(Q1 + Diagonal(length(x), x = 0.00001), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q1,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q1,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u1 = 5,
alpha1 = 0.1,
u2 = 5,
alpha2 = 0.1
)
tmbparams <- list(
W = rep(0, length(x)), # W = c(U); U = B-Spline coefficients
theta1 = 0, # -2log(sigma)
theta2 = 0
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "02_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
set.seed(123)
quad <- aghq::marginal_laplace_tmb(ff,7,c(0,0))
gx <- sample_marginal(quad, n_samp)
gx <- gx$samps
gz_list <- Interpolation_vec_v1(t = z_grid, x, gx, "RW2")
# gz <- Matrix(0,nrow = length(z_grid), ncol = n_samp)
# for (i in 1:length(gz_list)) {
#   gz[,i] <- gz_list[[i]]
# }
# mean_z <- apply(gz, 1, mean)
# upper_z <- apply(gz, 1, quantile, p = 0.975)
# lower_z <- apply(gz, 1, quantile, p = 0.025)
mean_x <- apply(gx, 1, mean)
# upper_x <- apply(gx, 1, quantile, p = 0.975)
# lower_x <- apply(gx, 1, quantile, p = 0.025)
sample_path <- Matrix(0,nrow = length(z), ncol = n_samp)
for (i in 1:length(gz_list)) {
sample_path[,i] <- rbind(gz_list[[i]], matrix(gx[,i],ncol = 1))
}
sample_path_rw2 <- as.tibble(as.matrix(sample_path))
sample_path_rw2$locations <- c(z_grid,x)
sample_path_rw2 <- arrange(sample_path_rw2, by = locations)
mean_y_rw2 <- apply(sample_path_rw2, 1, mean)
upper_y_rw2 <- apply(sample_path_rw2, 1, quantile, p = 0.975)
lower_y_rw2 <- apply(sample_path_rw2, 1, quantile, p = 0.025)
result_data <- data.frame(locations = sample_path_rw2$locations, mean_y = mean_y_rw2, upper_y = upper_y_rw2, lower_y = lower_y_rw2)
plot(result_data$mean_y ~ result_data$locations, type = 'l', xlab = "region of interest", ylab = "y", col = "red", ylim = c(-10,10), lty = 1)
lines(result_data$upper_y ~ result_data$locations, lty = 2, col = 'orange')
lines(result_data$lower_y ~ result_data$locations, lty = 2, col = 'orange')
lines(compute_g(result_data$locations) ~ result_data$locations, lty = 3, col = 'black')
points(mean_x ~ x, col = 'red')
for (i in sample.int(n_samp,30)) {
lines(unlist(sample_path_rw2[,i]) ~ z, col = rgb(0, 0, 255, max = 255, alpha = 20, names = "grey"))
}
title(main = "RW2 for sparse covariate: g(.)")
### compute rIAE and MCI
# sqrt(mean(abs(compute_g(z) - mean_y_rw2)))
# mean(upper_y_rw2 - lower_y_rw2)
D <- H[-c(1,length(x)),]
R <- B[-c(1,length(x)), -c(1,length(x))]
Q3 <- t(D) %*% solve(R) %*% D
Q3 <- as(as.matrix(Q3 + Diagonal(length(x), x = 0.00001)), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q3,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q3,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u1 = 5,
alpha1 = 0.1,
u2 = 5,
alpha2 = 0.1
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "02_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
set.seed(123)
quad <- aghq::marginal_laplace_tmb(ff,7,c(0,0))
gx <- sample_marginal(quad, n_samp)
gx <- gx$samps
gz_list <- Interpolation_vec_v1(t = z_grid, x, gx, "ARIMA")
gz <- Matrix(0,nrow = length(z_grid), ncol = n_samp)
for (i in 1:length(gz_list)) {
gz[,i] <- gz_list[[i]]
}
sample_path <- Matrix(0,nrow = length(z), ncol = n_samp)
for (i in 1:length(gz_list)) {
sample_path[,i] <- rbind(gz_list[[i]], matrix(gx[,i],ncol = 1))
}
mean_x <- apply(gx, 1, mean)
sample_path_arima <- as.tibble(as.matrix(sample_path))
sample_path_arima$locations <- c(z_grid,x)
sample_path_arima <- arrange(sample_path_arima, by = locations)
mean_y_arima <- apply(sample_path_arima, 1, mean)
upper_y_arima <- apply(sample_path_arima, 1, quantile, p = 0.975)
lower_y_arima <- apply(sample_path_arima, 1, quantile, p = 0.025)
result_data <- data.frame(locations = sample_path_arima$locations, mean_y = mean_y_arima, upper_y = upper_y_arima, lower_y = lower_y_arima)
plot(result_data$mean_y ~ result_data$locations, type = 'l', xlab = "region of interest", ylab = "y", col = "red", ylim = c(-10,10), lty = 1)
lines(result_data$upper_y ~ result_data$locations, lty = 2, col = 'orange')
lines(result_data$lower_y ~ result_data$locations, lty = 2, col = 'orange')
lines(compute_g(result_data$locations) ~ result_data$locations, lty = 3, col = 'black')
points(mean_x ~ x, col = 'red')
for (i in sample.int(n_samp,30)) {
lines(unlist(sample_path_arima[,i]) ~ z, col = rgb(0, 0, 255, max = 255, alpha = 20, names = "grey"))
}
title(main = "ARIMA for sparse covariate: g(.)")
### compute rIAE and MCI
# sqrt(mean(abs(compute_g(z) - mean_y_arima)))
# mean(upper_y_arima - lower_y_arima)
sample_path_rw2_1stDeriv <- apply(sample_path_rw2, 2, diff)
sample_path_rw2_1stDeriv[,2001] <- unlist(sample_path_rw2[,2001])[-1]
n_samp
n_samp <- 2000
sample_path_rw2_1stDeriv <- apply(sample_path_rw2, 2, diff)
sample_path_rw2_1stDeriv[,2001] <- unlist(sample_path_rw2[,2001])[-1]
### Simulation with sparse data: (n = 50)
n <- 50
z <- seq(0.5,100,0.5)
x <- seq(1,100, by = 10)
z_grid <- z[!z %in% x]
compute_g <- function(x){
5*sin(0.1*x)
}
y <- compute_g(rep(x, each = 5)) + rnorm(n, sd = sqrt(3))
d <- diff(x)
# X <- as(as.matrix(Diagonal(n)), "dgTMatrix")
X <- as(Matrix(0,nrow = 50, ncol = 10), "dgTMatrix")
for (i in 1:10) {
X[,i] <- c(rep(0, (i-1)*5), rep(1,5), rep(0, (45-(i-1)*5)))
}
H <- compute_H_rue(d,n = length(x))
B <- compute_B(d,n = length(x))
H <- compute_H_rue(d,n = length(x))
B <- compute_B(d,n = length(x))
A <- compute_A(d, n = length(x))
###### RW2:
Q1 <- t(H) %*% solve(A) %*% H
Q1 <- as(Q1 + Diagonal(length(x), x = 0.00001), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q1,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q1,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u1 = 5,
alpha1 = 0.1,
u2 = 5,
alpha2 = 0.1
)
tmbparams <- list(
W = rep(0, length(x)), # W = c(U); U = B-Spline coefficients
theta1 = 0, # -2log(sigma)
theta2 = 0
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "02_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
set.seed(123)
quad <- aghq::marginal_laplace_tmb(ff,7,c(0,0))
gx <- sample_marginal(quad, n_samp)
gx <- gx$samps
gz_list <- Interpolation_vec_v1(t = z_grid, x, gx, "RW2")
# gz <- Matrix(0,nrow = length(z_grid), ncol = n_samp)
# for (i in 1:length(gz_list)) {
#   gz[,i] <- gz_list[[i]]
# }
# mean_z <- apply(gz, 1, mean)
# upper_z <- apply(gz, 1, quantile, p = 0.975)
# lower_z <- apply(gz, 1, quantile, p = 0.025)
mean_x <- apply(gx, 1, mean)
# upper_x <- apply(gx, 1, quantile, p = 0.975)
# lower_x <- apply(gx, 1, quantile, p = 0.025)
sample_path <- Matrix(0,nrow = length(z), ncol = n_samp)
for (i in 1:length(gz_list)) {
sample_path[,i] <- rbind(gz_list[[i]], matrix(gx[,i],ncol = 1))
}
sample_path_rw2 <- as.tibble(as.matrix(sample_path))
sample_path_rw2$locations <- c(z_grid,x)
sample_path_rw2 <- arrange(sample_path_rw2, by = locations)
mean_y_rw2 <- apply(sample_path_rw2, 1, mean)
upper_y_rw2 <- apply(sample_path_rw2, 1, quantile, p = 0.975)
lower_y_rw2 <- apply(sample_path_rw2, 1, quantile, p = 0.025)
result_data <- data.frame(locations = sample_path_rw2$locations, mean_y = mean_y_rw2, upper_y = upper_y_rw2, lower_y = lower_y_rw2)
plot(result_data$mean_y ~ result_data$locations, type = 'l', xlab = "region of interest", ylab = "y", col = "red", ylim = c(-10,10), lty = 1)
lines(result_data$upper_y ~ result_data$locations, lty = 2, col = 'orange')
lines(result_data$lower_y ~ result_data$locations, lty = 2, col = 'orange')
lines(compute_g(result_data$locations) ~ result_data$locations, lty = 3, col = 'black')
points(mean_x ~ x, col = 'red')
for (i in sample.int(n_samp,30)) {
lines(unlist(sample_path_rw2[,i]) ~ z, col = rgb(0, 0, 255, max = 255, alpha = 20, names = "grey"))
}
title(main = "RW2 for sparse covariate: g(.)")
### compute rIAE and MCI
# sqrt(mean(abs(compute_g(z) - mean_y_rw2)))
# mean(upper_y_rw2 - lower_y_rw2)
D <- H[-c(1,length(x)),]
R <- B[-c(1,length(x)), -c(1,length(x))]
Q3 <- t(D) %*% solve(R) %*% D
Q3 <- as(as.matrix(Q3 + Diagonal(length(x), x = 0.00001)), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q3,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q3,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u1 = 5,
alpha1 = 0.1,
u2 = 5,
alpha2 = 0.1
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "02_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
set.seed(123)
quad <- aghq::marginal_laplace_tmb(ff,7,c(0,0))
gx <- sample_marginal(quad, n_samp)
gx <- gx$samps
gz_list <- Interpolation_vec_v1(t = z_grid, x, gx, "ARIMA")
gz <- Matrix(0,nrow = length(z_grid), ncol = n_samp)
for (i in 1:length(gz_list)) {
gz[,i] <- gz_list[[i]]
}
sample_path <- Matrix(0,nrow = length(z), ncol = n_samp)
for (i in 1:length(gz_list)) {
sample_path[,i] <- rbind(gz_list[[i]], matrix(gx[,i],ncol = 1))
}
mean_x <- apply(gx, 1, mean)
sample_path_arima <- as.tibble(as.matrix(sample_path))
sample_path_arima$locations <- c(z_grid,x)
sample_path_arima <- arrange(sample_path_arima, by = locations)
mean_y_arima <- apply(sample_path_arima, 1, mean)
upper_y_arima <- apply(sample_path_arima, 1, quantile, p = 0.975)
lower_y_arima <- apply(sample_path_arima, 1, quantile, p = 0.025)
result_data <- data.frame(locations = sample_path_arima$locations, mean_y = mean_y_arima, upper_y = upper_y_arima, lower_y = lower_y_arima)
plot(result_data$mean_y ~ result_data$locations, type = 'l', xlab = "region of interest", ylab = "y", col = "red", ylim = c(-10,10), lty = 1)
lines(result_data$upper_y ~ result_data$locations, lty = 2, col = 'orange')
lines(result_data$lower_y ~ result_data$locations, lty = 2, col = 'orange')
lines(compute_g(result_data$locations) ~ result_data$locations, lty = 3, col = 'black')
points(mean_x ~ x, col = 'red')
for (i in sample.int(n_samp,30)) {
lines(unlist(sample_path_arima[,i]) ~ z, col = rgb(0, 0, 255, max = 255, alpha = 20, names = "grey"))
}
title(main = "ARIMA for sparse covariate: g(.)")
### compute rIAE and MCI
# sqrt(mean(abs(compute_g(z) - mean_y_arima)))
# mean(upper_y_arima - lower_y_arima)
sample_path_rw2_1stDeriv <- apply(sample_path_rw2, 2, diff)
sample_path_rw2_1stDeriv[,2001] <- unlist(sample_path_rw2[,2001])[-1]
sample_path_rw2_1stDeriv_mean <- apply(sample_path_rw2_1stDeriv, 1, mean)
sample_path_rw2_1stDeriv_upper <- apply(sample_path_rw2_1stDeriv, 1, quantile, p = 0.975)
sample_path_rw2_1stDeriv_lower <- apply(sample_path_rw2_1stDeriv, 1, quantile, p = 0.025)
plot(diff(compute_g(z)) ~ z[-1], type = 'l', col = 'black',
xlab = "region of interest",
ylab = "1st deriv", ylim = c(-3,3), main = "RW2 for very sparse covariate: 1st deriv")
lines(sample_path_rw2_1stDeriv_mean ~ z[-1], col = 'red')
lines(sample_path_rw2_1stDeriv_upper ~ z[-1], col = 'orange', lty = 2)
lines(sample_path_rw2_1stDeriv_lower ~ z[-1], col = 'orange', lty = 2)
for (i in sample.int(n_samp,5)) {
lines(unlist(sample_path_rw2_1stDeriv[,i]) ~ sample_path_rw2_1stDeriv[,2001], col = rgb(0, 0, 255, max = 255, alpha = 20, names = "grey"))
}
# sqrt(mean(abs(diff(compute_g(z)) - sample_path_rw2_1stDeriv_mean)))
# mean(sample_path_rw2_1stDeriv_upper - sample_path_rw2_1stDeriv_lower)
sample_path_arima_1stDeriv <- apply(sample_path_arima, 2, diff)
sample_path_arima_1stDeriv[,2001] <- unlist(sample_path_arima[,2001])[-1]
sample_path_arima_1stDeriv_mean <- apply(sample_path_arima_1stDeriv, 1, mean)
sample_path_arima_1stDeriv_upper <- apply(sample_path_arima_1stDeriv, 1, quantile, p = 0.975)
sample_path_arima_1stDeriv_lower <- apply(sample_path_arima_1stDeriv, 1, quantile, p = 0.025)
plot(diff(compute_g(z)) ~ z[-1], type = 'l', col = 'black',
xlab = "region of interest",
ylab = "1st deriv", ylim = c(-3,3), main = "ARIMA for very sparse covariate: 1st deriv")
lines(sample_path_arima_1stDeriv_mean ~ z[-1], col = 'red')
lines(sample_path_arima_1stDeriv_upper ~ z[-1], col = 'orange', lty = 2)
lines(sample_path_arima_1stDeriv_lower ~ z[-1], col = 'orange', lty = 2)
for (i in sample.int(n_samp,5)) {
lines(unlist(sample_path_arima_1stDeriv[,i]) ~ sample_path_arima_1stDeriv[,2001], col = rgb(0, 0, 255, max = 255, alpha = 20, names = "grey"))
}
# sqrt(mean(abs(diff(compute_g(z)) - sample_path_arima_1stDeriv_mean)))
# mean(sample_path_arima_1stDeriv_upper - sample_path_arima_1stDeriv_lower)
sample_path_rw2_2ndDeriv <- apply(sample_path_rw2, 2, diff, differences = 2)
sample_path_rw2_2ndDeriv[,2001] <- unlist(sample_path_rw2[,2001])[-c(1,2)]
sample_path_rw2_2ndDeriv_mean <- apply(sample_path_rw2_2ndDeriv, 1, mean)
sample_path_rw2_2ndDeriv_upper <- apply(sample_path_rw2_2ndDeriv, 1, quantile, p = 0.975)
sample_path_rw2_2ndDeriv_lower <- apply(sample_path_rw2_2ndDeriv, 1, quantile, p = 0.025)
plot(diff(compute_g(z), differences = 2) ~ z[-c(1,2)], type = 'l', col = 'black',
xlab = "region of interest",
ylab = "2nd deriv", ylim = c(-1,1), main = "RW2 for very sparse covariate: 2nd deriv")
lines(sample_path_rw2_2ndDeriv_mean ~ z[-c(1,2)], col = 'red')
lines(sample_path_rw2_2ndDeriv_upper ~ z[-c(1,2)], col = 'orange', lty = 2)
lines(sample_path_rw2_2ndDeriv_lower ~ z[-c(1,2)], col = 'orange', lty = 2)
for (i in sample.int(n_samp,5)) {
lines(unlist(sample_path_rw2_2ndDeriv[,i]) ~ sample_path_rw2_2ndDeriv[,2001], col = rgb(0, 0, 255, max = 255, alpha = 20, names = "grey"))
}
# round(sqrt(mean(abs(diff(compute_g(z), differences = 2) - sample_path_rw2_2ndDeriv_mean))), 3)
# round(mean(sample_path_rw2_2ndDeriv_upper - sample_path_rw2_2ndDeriv_lower), 3)
sample_path_arima_2ndDeriv <- apply(sample_path_arima, 2, diff, differences = 2)
sample_path_arima_2ndDeriv[,2001] <- unlist(sample_path_arima[,2001])[-c(1,2)]
sample_path_arima_2ndDeriv_mean <- apply(sample_path_arima_2ndDeriv, 1, mean)
sample_path_arima_2ndDeriv_upper <- apply(sample_path_arima_2ndDeriv, 1, quantile, p = 0.975)
sample_path_arima_2ndDeriv_lower <- apply(sample_path_arima_2ndDeriv, 1, quantile, p = 0.025)
plot(diff(compute_g(z), differences = 2) ~ z[-c(1,2)], type = 'l', col = 'black',
xlab = "region of interest",
ylab = "2nd deriv", ylim = c(-1,1), main = "ARIMA for very sparse covariate: 2nd deriv")
lines(sample_path_arima_2ndDeriv_mean ~ z[-c(1,2)], col = 'red')
lines(sample_path_arima_2ndDeriv_upper ~ z[-c(1,2)], col = 'orange', lty = 2)
lines(sample_path_arima_2ndDeriv_lower ~ z[-c(1,2)], col = 'orange', lty = 2)
for (i in sample.int(n_samp,5)) {
lines(unlist(sample_path_arima_2ndDeriv[,i]) ~ sample_path_arima_2ndDeriv[,2001], col = rgb(0, 0, 255, max = 255, alpha = 20, names = "grey"))
}
# round(sqrt(mean(abs(diff(compute_g(z), differences = 2) - sample_path_arima_2ndDeriv_mean))), 3)
# round(mean(sample_path_arima_2ndDeriv_upper - sample_path_arima_2ndDeriv_lower), 3)
### Simulation with sparse data: (n = 50)
n <- 50
z <- seq(0.5,100,0.5)
x <- seq(1,100, by = 10)
z_grid <- z[!z %in% x]
compute_g <- function(x){
5*log(x)
}
y <- compute_g(rep(x, each = 5)) + rnorm(n, sd = sqrt(3))
d <- diff(x)
# X <- as(as.matrix(Diagonal(n)), "dgTMatrix")
X <- as(Matrix(0,nrow = 50, ncol = 10), "dgTMatrix")
for (i in 1:10) {
X[,i] <- c(rep(0, (i-1)*5), rep(1,5), rep(0, (45-(i-1)*5)))
}
H <- compute_H_rue(d,n = length(x))
B <- compute_B(d,n = length(x))
H <- compute_H_rue(d,n = length(x))
B <- compute_B(d,n = length(x))
A <- compute_A(d, n = length(x))
###### RW2:
Q1 <- t(H) %*% solve(A) %*% H
Q1 <- as(Q1 + Diagonal(length(x), x = 0.00001), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q1,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q1,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u1 = 5,
alpha1 = 0.1,
u2 = 5,
alpha2 = 0.1
)
tmbparams <- list(
W = rep(0, length(x)), # W = c(U); U = B-Spline coefficients
theta1 = 0, # -2log(sigma)
theta2 = 0
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "02_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
set.seed(123)
quad <- aghq::marginal_laplace_tmb(ff,7,c(0,0))
gx <- sample_marginal(quad, n_samp)
gx <- gx$samps
gz_list <- Interpolation_vec_v1(t = z_grid, x, gx, "RW2")
# gz <- Matrix(0,nrow = length(z_grid), ncol = n_samp)
# for (i in 1:length(gz_list)) {
#   gz[,i] <- gz_list[[i]]
# }
# mean_z <- apply(gz, 1, mean)
# upper_z <- apply(gz, 1, quantile, p = 0.975)
# lower_z <- apply(gz, 1, quantile, p = 0.025)
mean_x <- apply(gx, 1, mean)
# upper_x <- apply(gx, 1, quantile, p = 0.975)
# lower_x <- apply(gx, 1, quantile, p = 0.025)
sample_path <- Matrix(0,nrow = length(z), ncol = n_samp)
for (i in 1:length(gz_list)) {
sample_path[,i] <- rbind(gz_list[[i]], matrix(gx[,i],ncol = 1))
}
sample_path_rw2 <- as.tibble(as.matrix(sample_path))
sample_path_rw2$locations <- c(z_grid,x)
sample_path_rw2 <- arrange(sample_path_rw2, by = locations)
mean_y_rw2 <- apply(sample_path_rw2, 1, mean)
upper_y_rw2 <- apply(sample_path_rw2, 1, quantile, p = 0.975)
lower_y_rw2 <- apply(sample_path_rw2, 1, quantile, p = 0.025)
result_data <- data.frame(locations = sample_path_rw2$locations, mean_y = mean_y_rw2, upper_y = upper_y_rw2, lower_y = lower_y_rw2)
plot(result_data$mean_y ~ result_data$locations, type = 'l', xlab = "region of interest", ylab = "y", col = "red", ylim = c(-10,10), lty = 1)
lines(result_data$upper_y ~ result_data$locations, lty = 2, col = 'orange')
lines(result_data$lower_y ~ result_data$locations, lty = 2, col = 'orange')
lines(compute_g(result_data$locations) ~ result_data$locations, lty = 3, col = 'black')
points(mean_x ~ x, col = 'red')
for (i in sample.int(n_samp,30)) {
lines(unlist(sample_path_rw2[,i]) ~ z, col = rgb(0, 0, 255, max = 255, alpha = 20, names = "grey"))
}
title(main = "RW2 for sparse covariate: g(.)")
### compute rIAE and MCI
# sqrt(mean(abs(compute_g(z) - mean_y_rw2)))
# mean(upper_y_rw2 - lower_y_rw2)
D <- H[-c(1,length(x)),]
R <- B[-c(1,length(x)), -c(1,length(x))]
Q3 <- t(D) %*% solve(R) %*% D
Q3 <- as(as.matrix(Q3 + Diagonal(length(x), x = 0.00001)), "dgTMatrix")
tmbdat <- list(
# Design matrix
X = X,
# Penalty(Precision) matrix
P = Q3,
# Log determinant of penalty matrix (without the sigma part)
logPdet = as.numeric(determinant(Q3,logarithm = TRUE)$modulus),
# Response
y = y,
# PC Prior params
u1 = 5,
alpha1 = 0.1,
u2 = 5,
alpha2 = 0.1
)
ff <- TMB::MakeADFun(
data = tmbdat,
parameters = tmbparams,
random = "W",
DLL = "02_RW2Comparison",
silent = TRUE
)
# Hessian not implemented for RE models
ff$he <- function(w) numDeriv::jacobian(ff$gr,w)
# AGHQ
set.seed(123)
quad <- aghq::marginal_laplace_tmb(ff,7,c(0,0))
gx <- sample_marginal(quad, n_samp)
gx <- gx$samps
gz_list <- Interpolation_vec_v1(t = z_grid, x, gx, "ARIMA")
gz <- Matrix(0,nrow = length(z_grid), ncol = n_samp)
for (i in 1:length(gz_list)) {
gz[,i] <- gz_list[[i]]
}
sample_path <- Matrix(0,nrow = length(z), ncol = n_samp)
for (i in 1:length(gz_list)) {
sample_path[,i] <- rbind(gz_list[[i]], matrix(gx[,i],ncol = 1))
}
mean_x <- apply(gx, 1, mean)
sample_path_arima <- as.tibble(as.matrix(sample_path))
sample_path_arima$locations <- c(z_grid,x)
sample_path_arima <- arrange(sample_path_arima, by = locations)
mean_y_arima <- apply(sample_path_arima, 1, mean)
upper_y_arima <- apply(sample_path_arima, 1, quantile, p = 0.975)
lower_y_arima <- apply(sample_path_arima, 1, quantile, p = 0.025)
result_data <- data.frame(locations = sample_path_arima$locations, mean_y = mean_y_arima, upper_y = upper_y_arima, lower_y = lower_y_arima)
plot(result_data$mean_y ~ result_data$locations, type = 'l', xlab = "region of interest", ylab = "y", col = "red", ylim = c(-10,10), lty = 1)
lines(result_data$upper_y ~ result_data$locations, lty = 2, col = 'orange')
lines(result_data$lower_y ~ result_data$locations, lty = 2, col = 'orange')
lines(compute_g(result_data$locations) ~ result_data$locations, lty = 3, col = 'black')
points(mean_x ~ x, col = 'red')
for (i in sample.int(n_samp,30)) {
lines(unlist(sample_path_arima[,i]) ~ z, col = rgb(0, 0, 255, max = 255, alpha = 20, names = "grey"))
}
title(main = "ARIMA for sparse covariate: g(.)")
### compute rIAE and MCI
# sqrt(mean(abs(compute_g(z) - mean_y_arima)))
# mean(upper_y_arima - lower_y_arima)
